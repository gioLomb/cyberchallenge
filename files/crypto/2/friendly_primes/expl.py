from Crypto.Util.number import long_to_bytes
from math import prod

n = 420485447340750276798905009197900250076472236951029771396372239960455176076395356078018304176360377601355361640360458283456532642841066439541542468492600074303505516012322941130021941063141150150454719702821666531692873286236281808915376205692263441233138891193279355717503716920577044748917446320341294227
e = 65537
ct = 301134324702979101601229980817712305679459272403009847977905797426967147301009753074163263516519121214477239813381651880610545484766224816075639817078022502740923937485967968414814571266684481074873719521522276878916473424098420305091570571671905697759107642819692889627538051932664261696505877765760765011

# Fattori da FactorDB (verificati)
primes = [
    9259086589771420433,
    9432696100372252597,
    9905427204516677719,
    10742738836573593721,
    10877171163758298473,
    10883245204809972317,
    11387559472005576439,
    12361513190006588813,
    13008299345314386241,
    13137124577721543913,
    14444818318379665457,
    15197175261867744269,
    15313323964021172371,
    16259675972299142689,
    16659580147621910407,
    17447808094538811767
]

# Verifica la fattorizzazione
assert prod(primes) == n, "La fattorizzazione non Ã¨ corretta!"

# Calcola phi(n)
phi = 1
for p in primes:
    phi *= (p - 1)

# Calcola la chiave privata
d = pow(e, -1, phi)

# Decifra il messaggio
m = pow(ct, d, n)
flag = long_to_bytes(m)

print(f"Flag decifrata: {flag}")
print(f"Valore numerico: {m}")
print(f"Rappresentazione esadecimale: {hex(m)}")